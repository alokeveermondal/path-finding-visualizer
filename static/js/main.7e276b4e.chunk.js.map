{"version":3,"sources":["PathfindingVisualizer/Node/Node.js","PathfindingVisualizer/Algorithms/dfs.js","PathfindingVisualizer/Algorithms/dijkstra.js","PathfindingVisualizer/Mazes/maze.js","PathfindingVisualizer/Mazes/weightMaze.js","Navbar.js","PathfindingVisualizer/Mazes/hSkewMaze.js","PathfindingVisualizer/Mazes/vSkewMaze.js","PathfindingVisualizer/Data Structures/disjointSetItem.js","PathfindingVisualizer/Data Structures/disjointSet.js","PathfindingVisualizer/Mazes/kruskalsMaze1.js","PathfindingVisualizer/Mazes/primsMaze.js","PathfindingVisualizer/PathfindingVisualizer.js","PathfindingVisualizer/Mazes/wallMaze.js","PathfindingVisualizer/Algorithms/bfs.js","App.js","index.js"],"names":["Node","props","this","row","col","weight","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","onMouseLeave","extraClassName","id","className","React","Component","getChildren","node","grid","childElements","forEach","direction","childRow","childCol","length","child","isVisited","push","childNodes","childNode","costFromSource","parent","Math","min","extractMinIndex","dijkstraPQ","minNode","minNodeIndex","i","currentNode","createNode","finishNode","startNode","srow","scol","frow","fcol","isNode","Number","POSITIVE_INFINITY","removeWall","nodeA","nodeB","rowA","colA","rowB","colB","r","floor","c","maze","rowNum","colNum","newNode","initialGrid","dfsStack","random","pop","weightMaze","Navbar","onVisualizeClick","state","visualize","bfs","dfs","dijkstra","alert","bfsClick","setState","dfsClick","dijkstraClick","onWeightWallToggleClick","weightOrWall","weightWallToggle","componentDidMount","navbarHeight","document","getElementById","clientHeight","clearGrid","resetGrid","mazify","hmazify","vmazify","kruskalMazify","primMazify","weightMazify","wallMazify","clearWallsandWeights","href","data-toggle","onClick","type","vChildElements","hChildElements","horizontalSkewMaze","random1","verticalSkewMaze","DisjointSetItem","value","keyCallback","children","isRoot","getRoot","rank","getRank","Object","values","parentItem","forceSettingParentChild","addChild","childItem","getKey","setParent","DisjointSet","items","itemValue","disjointSetItem","templateDisjointItem","requiredDisjointItem","valueA","valueB","rootKeyA","find","rootKeyB","Error","rootA","rootB","disjointSet","index","hWallSet","vWallSet","kruskalMaze","makeSet","random2","neighborNodeRight","neighborNodeLeft","inSameSet","union","splice","unionJoint","primMaze","edgeQueue","PathfindingVisualizer","height","toggleIsRunning","isRunning","toggleWeightWallToggle","getInitialGrid","rowCount","ROW_COUNT","colCount","COLUMN_COUNT","currentRow","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","onCellDown","mouseIsPressed","startNodePressed","finishNodePressed","onCellEnter","onCellLeave","onCellRelease","componentWillMount","documentElement","clientWidth","hSkewMazify","vSkewMazify","wallMaze","algo","visitedNodesInOrder","minIndex","bfsQueue","childDirections","shift","x","y","nodesInShortestPathOrder","getNodesInShortestPathOrder","animate","setTimeout","animateShortestPath","nodeClassName","unshift","map","rowID","nodeID","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.7e276b4e.chunk.js","sourcesContent":["import React from 'react';\nimport './Node.css'\nclass Node extends React.Component {\n    constructor(props) {\n        super(props);\n    }\n    render() {\n        const {\n            row,\n            col,\n            weight,\n            isFinish,\n            isStart,\n            isWall,\n            onMouseDown,\n            onMouseEnter,\n            onMouseUp,\n            onMouseLeave,\n        } = this.props;\n        const extraClassName = isFinish ? \"node-finish\" : isStart ? \"node-start\" : isWall ? \"node-wall\" : \"\";\n        return (\n            <td\n                id={`node-${row}-${col}`}\n                className={`node ${extraClassName}`}\n                onMouseDown={() => onMouseDown(row, col)}\n                onMouseEnter={() => onMouseEnter(row, col)}\n                onMouseUp={() => onMouseUp()}\n                onMouseLeave={() => onMouseLeave(row,col)}\n            ><small>{weight === 1 ? \"\" : weight}</small></td> // It is used to create the grid.\n        );\n    }\n}\nexport default Node;","// DFS\n\nfunction getChildren(node, grid) {\n    const { row, col } = node;\n    const childElements = [];\n    const childDirections = [[1, 0], [0, 1], [-1, 0], [0, -1]];\n\n    childDirections.forEach(direction => {\n        const childRow = row + direction[0];\n        const childCol = col + direction[1];\n        if (childRow >= 0 && childCol >= 0 && childRow < grid.length && childCol < grid[0].length) {\n            const child = grid[childRow][childCol];\n            if (!child.isVisited && !child.isWall) {\n                // child.isVisited = true;\n                childElements.push(child);\n            }\n        }\n    })\n\n    return childElements;\n}\n\n\nexport function dfs(grid,startNode,finishNode){\n    const visitedNodesInOrder = [startNode];\n    startNode.isVisited= true;\n    let currentNode = startNode;\n    let dfsStack = [currentNode];\n    while (dfsStack.length) {\n        if(currentNode.isFinish) return visitedNodesInOrder;\n        const childElements = getChildren(currentNode, grid);\n        if (childElements.length) {\n            childElements[0].parent = currentNode;\n            currentNode = childElements[0];\n            currentNode.isVisited = true;\n            visitedNodesInOrder.push(currentNode);\n            dfsStack.push(currentNode);\n        }\n        else { \n            dfsStack.pop();\n            currentNode = dfsStack[dfsStack.length-1];\n        }\n    }\n    return visitedNodesInOrder;\n}\n","// Dijkstra\n\nfunction getChildren (grid,node){\n    const childDirections = [[1,0],[0,1],[-1,0],[0,-1]];\n    const childNodes = [];\n    const {row,col} = node;\n    childDirections.forEach(direction=>{\n        const childRow = row + direction[0];\n        const childCol = col + direction[1];\n\n        if(childRow >=0&& childCol>=0 && childCol<grid[0].length && childRow<grid.length)\n        {\n            const childNode = grid[childRow][childCol];\n            if(!childNode.isVisited && !childNode.isWall)\n            {\n                childNodes.push(childNode);\n                if(childNode.costFromSource > node.costFromSource + childNode.weight)\n                {\n                    childNode.parent = node;\n                }\n                childNode.costFromSource = Math.min(childNode.costFromSource, node.costFromSource + childNode.weight);\n            }\n            else if(childNode.isVisited)\n            {\n                if (childNode.costFromSource > node.costFromSource + childNode.weight) {\n                    childNode.parent = node;\n                }\n                childNode.costFromSource = Math.min(childNode.costFromSource, node.costFromSource + childNode.weight);\n                // console.log(\"parent = \",row,col,childNode.costFromSource)\n            }\n        }\n    })\n    return childNodes;\n}\n\nfunction extractMinIndex (dijkstraPQ){\n    let minNode = dijkstraPQ[0];\n    let minNodeIndex=0;\n    for(let i=1;i<dijkstraPQ.length;i++)\n    {\n        let currentNode = dijkstraPQ[i];\n        if(minNode.costFromSource > currentNode.costFromSource)\n        {\n            minNode = currentNode;\n            minNodeIndex = i;\n        }\n    }\n    return minNodeIndex;\n}\n\nexport function dijkstra(grid,startNode,finishNode){\n    const visitedNodesInOrder = [];\n\n    let currentNode;\n    let dijkstraPQ = [startNode];\n    startNode.isVisited=true;\n    while(dijkstraPQ.length)\n    {\n\n        const minIndex = extractMinIndex(dijkstraPQ);\n        currentNode = dijkstraPQ[minIndex];\n        if(currentNode.isFinish) return visitedNodesInOrder;\n\n        visitedNodesInOrder.push(currentNode);\n        const childNodes = getChildren(grid,currentNode);\n        childNodes.forEach(node => {\n            dijkstraPQ.push(node);\n            node.isVisited=true;\n        });\n        dijkstraPQ.splice(minIndex,1);\n    }\n    return visitedNodesInOrder;\n}\n\n","function createNode (row,col,finishNode,startNode){\n    const srow = startNode.row;\n    const scol = startNode.col;\n    const frow = finishNode.row;\n    const fcol = finishNode.col;\n    return {\n        row : row,\n        col : col,\n        isVisited : false,\n        isWall : false,\n        parent: null,\n        isNode: true,\n        isStart:\n            row === srow && col === scol,\n        isFinish:\n            row === frow && col === fcol,\n        weight :1,\n        costFromSource: (row === srow && col === scol) ? 0 : Number.POSITIVE_INFINITY,\n    };\n}\n\n// assumed rowNum ans colNum are odd\n\nfunction initialGrid (rowNum,colNum,startNode,finishNode){\n    const grid = [];\n    for(let r = 0;r<rowNum;r++)\n    {\n        const row = [];\n        for(let c = 0; c<colNum;c++)\n        {\n            const newNode = createNode(r,c,finishNode,startNode);\n            if((r%2===0 || c%2===0 )) newNode.isWall = true;\n            if(newNode.isFinish || newNode.isStart) newNode.isWall = false;\n            row.push(newNode);\n        }\n        grid.push(row);\n    }\n    return grid;\n}\n\nfunction getChildren (node,grid){\n    const {row,col} = node;\n    const childElements = [];\n    const childDirections = [[2,0],[0,2],[-2,0],[0,-2]];\n    \n    childDirections.forEach(direction=>{\n        const childRow = row + direction[0];\n        const childCol = col + direction[1];\n        if(childRow>=0 && childCol >=0 && childRow < grid.length && childCol < grid[0].length)\n        {\n            const child = grid[childRow][childCol];\n            if(!child.isVisited)\n            {\n                // child.isVisited = true;\n                childElements.push(child);\n            }\n        }\n    })\n\n    return childElements;\n}\n\nfunction removeWall(nodeA,nodeB,grid){\n    \n    const rowA = nodeA.row;\n    const colA = nodeA.col;\n    const rowB = nodeB.row;\n    const colB = nodeB.col;\n\n    const r = Math.floor((rowA+rowB)/2);\n    const c = Math.floor((colA+colB)/2);\n\n    grid[r][c].isWall = false;\n    return;\n}\n\nexport function maze(rowNum,colNum,startNode,finishNode){\n    const grid = initialGrid(rowNum,colNum,startNode,finishNode);\n    // console.log(grid);\n    \n    let currentNode = grid[1][1];\n    let dfsStack = [currentNode];\n\n    while(dfsStack.length)\n    {\n        const childElements = getChildren(currentNode,grid);\n        if(childElements.length)\n        {\n            const random = Math.floor(Math.random() * childElements.length);\n            // console.log(currentNode, childElements[random], removeWall(currentNode, childElements[random]));\n            removeWall(currentNode,childElements[random],grid);\n            currentNode = childElements[random];\n            currentNode.isVisited = true;\n            dfsStack.push(currentNode);\n        }\n        else\n        {\n            currentNode = dfsStack.pop();\n        }\n        // console.log(currentNode);\n    }\n    grid.forEach(row=>{\n        row.forEach(node => {\n            node.isVisited = false;\n        });\n    });\n    // console.log(grid);\n    return grid;\n}\n\n","function distribution(){\n    const random1 = Math.random();\n    if(random1 <0.5)\n    {\n        const random2 = Math.floor(Math.random()*10 + 1);\n        return random2;\n    }\n    return 1;\n}\nexport function weightMaze(grid){\n    grid.forEach(row=>{\n        row.forEach(node =>{\n            if(!node.isWall){\n                node.weight = distribution();\n            }\n        });\n    });\n    return grid;\n}","import React from 'react';\n\n// function navbarHeight(){\n//     return document.getElementById(\"navbarDiv\").clientHeight;\n// }\nclass Navbar extends React.Component {\n    constructor(props)\n    {\n        super(props);\n        this.state = {\n            visualize:'',\n            weightOrWall : false,\n        }\n    }\n    onVisualizeClick = () => {\n        const visualize = this.state.visualize;\n        switch(visualize){\n            case 'BFS':\n                this.props.bfs();\n                break;\n            case 'DFS':\n                this.props.dfs();\n                break;\n            case 'Dijkstra':\n                this.props.dijkstra();\n                break;\n            default:\n                alert('Choose an algorithm for visualization!!');\n        }\n        // console.log(visualize);\n    }\n    bfsClick = ()=>{\n        this.setState({visualize : 'BFS'});\n    }\n    dfsClick = ()=>{\n        this.setState({ visualize: 'DFS' });\n    }\n    dijkstraClick = ()=>{\n        this.setState({ visualize: 'Dijkstra' });\n    }\n    onWeightWallToggleClick = () =>{\n        const weightOrWall = !this.state.weightOrWall;\n        this.setState({weightOrWall});\n        this.props.weightWallToggle();\n    }\n    componentDidMount = ()=> {\n        // console.log(document.getElementById(\"navbarDiv\").clientHeight);\n        this.props.navbarHeight(document.getElementById(\"navbarDiv\").clientHeight);\n    }\n    render() {\n        const {\n            clearGrid,\n            resetGrid,\n            mazify,\n            hmazify,\n            vmazify,\n            kruskalMazify,\n            primMazify,\n            weightMazify,\n            wallMazify,\n            clearWallsandWeights,\n        } = this.props;\n\n        return (\n            <div id='navbarDiv'>\n                <nav className=\"navbar navbar-inverse\">\n                    <div className=\"container-fluid\">\n                        <div className=\"navbar-header\">\n                            <a id=\"refreshButton\" className=\"navbar-brand\" href=\"#\">Pathfinding Visualizer</a>\n                        </div>\n                        <ul className=\"nav navbar-nav\">\n                            <li className=\"dropdown\">\n                                <a className=\"dropdown-toggle\" data-toggle=\"dropdown\" href=\"#\">Algorithms\n             <span className=\"caret\"></span></a>\n                                <ul className=\"dropdown-menu\">\n                                    <li id='startButtonDijkstra'><a href=\"#\" onClick = {this.dijkstraClick}>Dijkstra's Algorithm</a></li>\n                                    {/* <li id='startButtonAStar2'><a href=\"#\">A* Search</a></li> */}\n                                    {/* <li id='startButtonGreedy'><a href=\"#\">Greedy Best-first Search</a></li>\n                                    <li id='startButtonAStar'><a href=\"#\">Swarm Algorithm</a></li> */}\n                                    {/* <li id='startButtonAStar3'><a href=\"#\">Convergent Swarm Algorithm</a></li>\n                                    <li id='startButtonBidirectional'><a href=\"#\">Bidirectional Swarm Algorithm</a></li> */}\n                                    <li id='startButtonBFS'><a href=\"#\" onClick = {this.bfsClick}>Breadth-first Search</a></li>\n                                    <li id='startButtonDFS'><a href=\"#\" onClick = {this.dfsClick}>Depth-first Search</a></li>\n                                </ul>\n                            </li>\n                            <li className=\"dropdown\">\n                                <a className=\"dropdown-toggle\" data-toggle=\"dropdown\" href=\"#\">Mazes &amp; Patterns\n             <span className=\"caret\"></span></a>\n                                <ul className=\"dropdown-menu\">\n                                    <li id='startButtonCreateMazeTwo'><a href=\"#\" onClick = {mazify}>Recursive Division</a></li>\n                                    <li id='startButtonCreateMazeThree'><a href=\"#\" onClick = {vmazify}>Recursive Division (vertical skew)</a></li>\n                                    <li id='startButtonCreateMazeFour'><a href=\"#\" onClick={hmazify}>Recursive Division (horizontal skew)</a></li>\n                                    <li id='startButtonCreateMazeFour'><a href=\"#\" onClick={kruskalMazify}>Kruskal's Maze</a></li>\n                                    <li id='startButtonCreateMazeFour'><a href=\"#\" onClick={primMazify}>Prims's Maze</a></li>\n                                    <li id='startButtonCreateMazeOne'><a href=\"#\" onClick = {wallMazify}>Basic Random Maze</a></li>\n                                    <li id='startButtonCreateMazeWeights'><a href=\"#\" onClick = {weightMazify}>Basic Weight Maze</a></li>\n                                    {/* <li id='startStairDemonstration'><a href=\"#\">Simple Stair Pattern</a></li> */}\n                                </ul>\n                            </li>\n                            <li id='startButtonAddObject'><a href=\"#\" onClick = {this.onWeightWallToggleClick}>Add {this.state.weightOrWall ? 'Wall':'Weight'}</a></li>\n                            <li id='startButtonStart'><button id=\"actualStartButton\" className=\"btn btn-default navbar-btn\" type=\"button\" onClick = {this.onVisualizeClick}>Visualize {this.state.visualize}!</button></li>\n                            <li id='startButtonClearBoard'><a href=\"#\" onClick = {resetGrid}>Clear Board</a></li>\n                            <li id='startButtonClearWalls'><a href=\"#\" onClick = {clearWallsandWeights}>Clear Walls &amp; Weights</a></li>\n                            <li id='startButtonClearPath'><a href=\"#\" onClick={clearGrid}>Clear Path</a></li>\n                            {/* <li className=\"dropdown\">\n                                <a id=\"adjustSpeed\" className=\"dropdown-toggle\" data-toggle=\"dropdown\" href=\"#\">Speed: Fast\n             <span className=\"caret\"></span></a>\n                                <ul className=\"dropdown-menu\">\n                                    <li id='adjustFast'><a href=\"#\">Fast</a></li>\n                                    <li id='adjustAverage'><a href=\"#\">Average</a></li>\n                                    <li id='adjustSlow'><a href=\"#\">Slow</a></li>\n                                </ul>\n                            </li> */}\n                        </ul>\n                    </div>\n                </nav>\n            </div>\n        );\n    }\n}\n\nexport default Navbar;","function createNode(row, col, finishNode, startNode) {\n    const srow = startNode.row;\n    const scol = startNode.col;\n    const frow = finishNode.row;\n    const fcol = finishNode.col;\n    return {\n        row: row,\n        col: col,\n        isVisited: false,\n        isWall: false,\n        parent: null,\n        isNode: true,\n        isStart:\n            row === srow && col === scol,\n        isFinish:\n            row === frow && col === fcol,\n        weight: 1,\n        costFromSource: (row === srow && col === scol) ? 0 : Number.POSITIVE_INFINITY,\n    };\n}\n\n// assumed rowNum ans colNum are odd\n\nfunction initialGrid(rowNum, colNum, startNode, finishNode) {\n    const grid = [];\n    for (let r = 0; r < rowNum; r++) {\n        const row = [];\n        for (let c = 0; c < colNum; c++) {\n            const newNode = createNode(r, c, finishNode, startNode);\n            if ((r % 2 === 0 || c % 2 === 0)) newNode.isWall = true;\n            if (newNode.isFinish || newNode.isStart) newNode.isWall = false;\n            row.push(newNode);\n        }\n        grid.push(row);\n    }\n    return grid;\n}\n\nfunction getChildren(node, grid) {\n    const { row, col } = node;\n    const childElements = [];\n    const hChildDirections = [[2, 0], [-2, 0]];\n    const vChildDirections = [[0, 2], [0, -2]];\n    // const childDirections = [[2,0],[0,2],[-2,0],[0,-2]];\n\n    const vChildElements = [];\n    vChildDirections.forEach(direction => {\n        const childRow = row + direction[0];\n        const childCol = col + direction[1];\n        if (childRow >= 0 && childCol >= 0 && childRow < grid.length && childCol < grid[0].length) {\n            const child = grid[childRow][childCol];\n            if (!child.isVisited) {\n                // child.isVisited = true;\n                vChildElements.push(child);\n            }\n        }\n    });\n    childElements.push(vChildElements);\n\n    const hChildElements = [];\n    hChildDirections.forEach(direction => {\n        const childRow = row + direction[0];\n        const childCol = col + direction[1];\n        if (childRow >= 0 && childCol >= 0 && childRow < grid.length && childCol < grid[0].length) {\n            const child = grid[childRow][childCol];\n            if (!child.isVisited) {\n                // child.isVisited = true;\n                hChildElements.push(child);\n            }\n        }\n    });\n    childElements.push(hChildElements);\n\n    return childElements;\n}\n\nfunction removeWall(nodeA, nodeB, grid) {\n\n    const rowA = nodeA.row;\n    const colA = nodeA.col;\n    const rowB = nodeB.row;\n    const colB = nodeB.col;\n\n    const r = Math.floor((rowA + rowB) / 2);\n    const c = Math.floor((colA + colB) / 2);\n\n    grid[r][c].isWall = false;\n    return;\n    // return grid[r][c];\n\n}\n\nexport function horizontalSkewMaze(rowNum, colNum, startNode, finishNode) {\n    const grid = initialGrid(rowNum, colNum, startNode, finishNode);\n    // console.log(grid);\n\n    let currentNode = grid[1][1];\n    let dfsStack = [currentNode];\n\n    while (dfsStack.length) {\n        const childElements = getChildren(currentNode, grid);\n        if (childElements[0].length || childElements[1].length) {\n            const random1 = Math.floor(Math.random() * 4);\n            if (random1 !== 3 && childElements[0].length) {\n                const random = Math.floor(Math.random() * childElements[0].length);\n                removeWall(currentNode, childElements[0][random], grid);\n                currentNode = childElements[0][random];\n                currentNode.isVisited = true;\n                dfsStack.push(currentNode);\n            }\n            else if (random1 === 3 && childElements[1].length) {\n                const random = Math.floor(Math.random() * childElements[1].length);\n                removeWall(currentNode, childElements[1][random], grid);\n                currentNode = childElements[1][random];\n                currentNode.isVisited = true;\n                dfsStack.push(currentNode);\n            }\n            else if (childElements[1].length) {\n                const random = Math.floor(Math.random() * childElements[1].length);\n                removeWall(currentNode, childElements[1][random], grid);\n                currentNode = childElements[1][random];\n                currentNode.isVisited = true;\n                dfsStack.push(currentNode);\n            }\n            else {\n                const random = Math.floor(Math.random() * childElements[0].length);\n                // console.log(currentNode, childElements[random], removeWall(currentNode, childElements[random]));\n                removeWall(currentNode, childElements[0][random], grid);\n                currentNode = childElements[0][random];\n                currentNode.isVisited = true;\n                dfsStack.push(currentNode);\n            }\n        }\n        else {\n            currentNode = dfsStack.pop();\n        }\n    }\n    grid.forEach(row => {\n        row.forEach(node => {\n            node.isVisited = false;\n        });\n    });\n    // console.log(grid);\n    return grid;\n}","function createNode(row, col, finishNode, startNode) {\n    const srow = startNode.row;\n    const scol = startNode.col;\n    const frow = finishNode.row;\n    const fcol = finishNode.col;\n    return {\n        row: row,\n        col: col,\n        isVisited: false,\n        isWall: false,\n        parent: null,\n        isNode: true,\n        isStart:\n            row === srow && col === scol,\n        isFinish:\n            row === frow && col === fcol,\n        weight: 1,\n        costFromSource: (row === srow && col === scol) ? 0 : Number.POSITIVE_INFINITY,\n    };\n}\n\n// assumed rowNum ans colNum are odd\n\nfunction initialGrid(rowNum, colNum, startNode, finishNode) {\n    const grid = [];\n    for (let r = 0; r < rowNum; r++) {\n        const row = [];\n        for (let c = 0; c < colNum; c++) {\n            const newNode = createNode(r, c, finishNode, startNode);\n            if ((r % 2 === 0 || c % 2 === 0)) newNode.isWall = true;\n            if (newNode.isFinish || newNode.isStart) newNode.isWall = false;\n            row.push(newNode);\n        }\n        grid.push(row);\n    }\n    return grid;\n}\n\nfunction getChildren(node, grid) {\n    const { row, col } = node;\n    const childElements = [];\n    const hChildDirections = [[2, 0], [-2, 0]];\n    const vChildDirections = [[0, 2], [0, -2]];\n    // const childDirections = [[2,0],[0,2],[-2,0],[0,-2]];\n\n    const hChildElements = [];\n    hChildDirections.forEach(direction => {\n        const childRow = row + direction[0];\n        const childCol = col + direction[1];\n        if (childRow >= 0 && childCol >= 0 && childRow < grid.length && childCol < grid[0].length) {\n            const child = grid[childRow][childCol];\n            if (!child.isVisited) {\n                // child.isVisited = true;\n                hChildElements.push(child);\n            }\n        }\n    });\n    childElements.push(hChildElements);\n\n    const vChildElements = [];\n    vChildDirections.forEach(direction => {\n        const childRow = row + direction[0];\n        const childCol = col + direction[1];\n        if (childRow >= 0 && childCol >= 0 && childRow < grid.length && childCol < grid[0].length) {\n            const child = grid[childRow][childCol];\n            if (!child.isVisited) {\n                // child.isVisited = true;\n                vChildElements.push(child);\n            }\n        }\n    });\n    childElements.push(vChildElements);\n    return childElements;\n}\n\nfunction removeWall(nodeA, nodeB, grid) {\n\n    const rowA = nodeA.row;\n    const colA = nodeA.col;\n    const rowB = nodeB.row;\n    const colB = nodeB.col;\n\n    const r = Math.floor((rowA + rowB) / 2);\n    const c = Math.floor((colA + colB) / 2);\n\n    grid[r][c].isWall = false;\n    return;\n    // return grid[r][c];\n\n}\n\nexport function verticalSkewMaze(rowNum, colNum, startNode, finishNode) {\n    const grid = initialGrid(rowNum, colNum, startNode, finishNode);\n    // console.log(grid);\n\n    let currentNode = grid[1][1];\n    let dfsStack = [currentNode];\n\n    while (dfsStack.length) {\n        const childElements = getChildren(currentNode, grid);\n        if (childElements[0].length || childElements[1].length) {\n            const random1 = Math.floor(Math.random() * 4);\n            if (random1 !== 3 && childElements[0].length) {\n                const random = Math.floor(Math.random() * childElements[0].length);\n                removeWall(currentNode, childElements[0][random], grid);\n                currentNode = childElements[0][random];\n                currentNode.isVisited = true;\n                dfsStack.push(currentNode);\n            }\n            else if (random1 === 3 && childElements[1].length) {\n                const random = Math.floor(Math.random() * childElements[1].length);\n                removeWall(currentNode, childElements[1][random], grid);\n                currentNode = childElements[1][random];\n                currentNode.isVisited = true;\n                dfsStack.push(currentNode);\n            }\n            else if (childElements[1].length) {\n                const random = Math.floor(Math.random() * childElements[1].length);\n                removeWall(currentNode, childElements[1][random], grid);\n                currentNode = childElements[1][random];\n                currentNode.isVisited = true;\n                dfsStack.push(currentNode);\n            }\n            else {\n                const random = Math.floor(Math.random() * childElements[0].length);\n                // console.log(currentNode, childElements[random], removeWall(currentNode, childElements[random]));\n                removeWall(currentNode, childElements[0][random], grid);\n                currentNode = childElements[0][random];\n                currentNode.isVisited = true;\n                dfsStack.push(currentNode);\n            }\n        }\n        else {\n            currentNode = dfsStack.pop();\n        }\n    }\n    grid.forEach(row => {\n        row.forEach(node => {\n            node.isVisited = false;\n        });\n    });\n    // console.log(grid);\n    return grid;\n}\n\n","export default class DisjointSetItem {\n    /**\n     * @param {*} value\n     * @param {function(value: *)} [keyCallback]\n     */\n    constructor(value, keyCallback) {\n        this.value = value;\n        this.keyCallback = keyCallback;\n        /** @var {DisjointSetItem} this.parent */\n        this.parent = null;\n        this.children = {};\n    }\n\n    /**\n     * @return {*}\n     */\n    getKey() {\n        // Allow user to define custom key generator.\n        if (this.keyCallback) {\n            return this.keyCallback(this.value);\n        }\n\n        // Otherwise use value as a key by default.\n        return this.value;\n    }\n\n    /**\n     * @return {DisjointSetItem}\n     */\n    getRoot() {\n        return this.isRoot() ? this : this.parent.getRoot();\n    }\n\n    /**\n     * @return {boolean}\n     */\n    isRoot() {\n        return this.parent === null;\n    }\n\n    /**\n     * Rank basically means the number of all ancestors.\n     *\n     * @return {number}\n     */\n    getRank() {\n        if (this.getChildren().length === 0) {\n            return 0;\n        }\n\n        let rank = 0;\n\n        /** @var {DisjointSetItem} child */\n        this.getChildren().forEach((child) => {\n            // Count child itself.\n            rank += 1;\n\n            // Also add all children of current child.\n            rank += child.getRank();\n        });\n\n        return rank;\n    }\n\n    /**\n     * @return {DisjointSetItem[]}\n     */\n    getChildren() {\n        return Object.values(this.children);\n    }\n\n    /**\n     * @param {DisjointSetItem} parentItem\n     * @param {boolean} forceSettingParentChild\n     * @return {DisjointSetItem}\n     */\n    setParent(parentItem, forceSettingParentChild = true) {\n        this.parent = parentItem;\n        if (forceSettingParentChild) {\n            parentItem.addChild(this);\n        }\n\n        return this;\n    }\n\n    /**\n     * @param {DisjointSetItem} childItem\n     * @return {DisjointSetItem}\n     */\n    addChild(childItem) {\n        this.children[childItem.getKey()] = childItem;\n        childItem.setParent(this, false);\n\n        return this;\n    }\n}","import DisjointSetItem from './disjointSetItem';\n\nexport default class DisjointSet {\n    /**\n     * @param {function(value: *)} [keyCallback]\n     */\n    constructor(keyCallback) {\n        this.keyCallback = keyCallback;\n        this.items = {};\n    }\n\n    /**\n     * @param {*} itemValue\n     * @return {DisjointSet}\n     */\n    makeSet(itemValue) {\n        const disjointSetItem = new DisjointSetItem(itemValue, this.keyCallback);\n\n        if (!this.items[disjointSetItem.getKey()]) {\n            // Add new item only in case if it not presented yet.\n            this.items[disjointSetItem.getKey()] = disjointSetItem;\n        }\n\n        return this;\n    }\n\n    /**\n     * Find set representation node.\n     *\n     * @param {*} itemValue\n     * @return {(string|null)}\n     */\n    find(itemValue) {\n        const templateDisjointItem = new DisjointSetItem(itemValue, this.keyCallback);\n\n        // Try to find item itself;\n        const requiredDisjointItem = this.items[templateDisjointItem.getKey()];\n\n        if (!requiredDisjointItem) {\n            return null;\n        }\n\n        return requiredDisjointItem.getRoot().getKey();\n    }\n\n    /**\n     * Union by rank.\n     *\n     * @param {*} valueA\n     * @param {*} valueB\n     * @return {DisjointSet}\n     */\n    union(valueA, valueB) {\n        const rootKeyA = this.find(valueA);\n        const rootKeyB = this.find(valueB);\n\n        if (rootKeyA === null || rootKeyB === null) {\n            throw new Error('One or two values are not in sets');\n        }\n\n        if (rootKeyA === rootKeyB) {\n            // In case if both elements are already in the same set then just return its key.\n            return this;\n        }\n\n        const rootA = this.items[rootKeyA];\n        const rootB = this.items[rootKeyB];\n\n        if (rootA.getRank() < rootB.getRank()) {\n            // If rootB's tree is bigger then make rootB to be a new root.\n            rootB.addChild(rootA);\n\n            return this;\n        }\n\n        // If rootA's tree is bigger then make rootA to be a new root.\n        rootA.addChild(rootB);\n\n        return this;\n    }\n\n    /**\n     * @param {*} valueA\n     * @param {*} valueB\n     * @return {boolean}\n     */\n    inSameSet(valueA, valueB) {\n        const rootKeyA = this.find(valueA);\n        const rootKeyB = this.find(valueB);\n\n        if (rootKeyA === null || rootKeyB === null) {\n            throw new Error('One or two values are not in sets');\n        }\n\n        return rootKeyA === rootKeyB;\n    }\n}","// with data structure\n// working fine\nimport DisjointSet from '../Data Structures/disjointSet';\nlet disjointSet = new DisjointSet((node)=>{\n    return node.index;\n});\nfunction createNode(row, col, finishNode, startNode) {\n    const srow = startNode.row;\n    const scol = startNode.col;\n    const frow = finishNode.row;\n    const fcol = finishNode.col;\n    return {\n        row: row,\n        col: col,\n        isVisited: false,\n        isWall: false,\n        parent: null,\n        isNode: true,\n        isStart:\n            row === srow && col === scol,\n        isFinish:\n            row === frow && col === fcol,\n        weight: 1,\n        costFromSource: (row === srow && col === scol) ? 0 : Number.POSITIVE_INFINITY,\n        index: -1,\n    };\n}\nlet hWallSet = [];\nlet vWallSet = [];\nlet rootNodeIndex = [];\nfunction initialGrid(rowNum, colNum, startNode, finishNode) {\n    disjointSet = new DisjointSet((node) => {\n        return node.index;\n    });\n    hWallSet = [];\n    vWallSet = [];\n    const grid = [];\n    let i = 0;\n    for (let r = 0; r < rowNum; r++) {\n        const row = [];\n        for (let c = 0; c < colNum; c++) {\n            const newNode = createNode(r, c, finishNode, startNode);\n            if ((r % 2 === 0 || c % 2 === 0)) {\n                newNode.isWall = true;\n                if (c % 2 === 0 && r % 2 === 1 && c > 0 && c < colNum - 1) {\n                    hWallSet.push(newNode);\n                }\n                else if (r % 2 === 0 && c % 2 === 1 && r > 0 && r < rowNum - 1) {\n                    vWallSet.push(newNode);\n                }\n            }\n            else {\n                newNode.index = i;\n                // rootNodeIndex.push(i);\n                i++;\n                disjointSet.makeSet(newNode);\n            }\n            if (newNode.isFinish || newNode.isStart) newNode.isWall = false;\n            row.push(newNode);\n        }\n        grid.push(row);\n    }\n    return grid;\n}\nexport function kruskalMaze(rowNum, colNum, startNode, finishNode) {\n    const grid = initialGrid(rowNum, colNum, startNode, finishNode);\n    // console.log(hWallSet.length);\n    // console.log(vWallSet.length);\n    while(hWallSet.length || vWallSet.length) {\n        const random1 = Math.floor(Math.random() * 2);\n        if (random1 && hWallSet.length) {\n            const random2 = Math.floor(Math.random() * hWallSet.length);\n            const node = hWallSet[random2];\n            const { row, col } = node;\n            const neighborNodeRight = grid[row][col + 1];\n            const neighborNodeLeft = grid[row][col - 1];\n            if (!disjointSet.inSameSet(neighborNodeLeft,neighborNodeRight)) {\n                node.isWall = false;\n                disjointSet.union(neighborNodeLeft,neighborNodeRight);\n            }\n            hWallSet.splice(random2, 1);\n        }\n        else if (!random1 && vWallSet.length) {\n            const random2 = Math.floor(Math.random() * vWallSet.length);\n            const node = vWallSet[random2];\n            const { row, col } = node;\n            const neighborNodeRight = grid[row + 1][col];\n            const neighborNodeLeft = grid[row - 1][col];\n            if (!disjointSet.inSameSet(neighborNodeLeft, neighborNodeRight)) {\n                node.isWall = false;\n                disjointSet.union(neighborNodeLeft, neighborNodeRight);\n            }\n            vWallSet.splice(random2, 1);\n        }\n        else if (hWallSet.length) {\n            const random2 = Math.floor(Math.random() * hWallSet.length);\n            const node = hWallSet[random2];\n            const { row, col } = node;\n            const neighborNodeRight = grid[row][col + 1];\n            const neighborNodeLeft = grid[row][col - 1];\n            if (!disjointSet.inSameSet(neighborNodeLeft, neighborNodeRight)) {\n                node.isWall = false;\n                disjointSet.union(neighborNodeLeft, neighborNodeRight);\n            }\n            hWallSet.splice(random2, 1);\n        }\n        else if (vWallSet.length) {\n            const random2 = Math.floor(Math.random() * vWallSet.length);\n            const node = vWallSet[random2];\n            const { row, col } = node;\n            const neighborNodeRight = grid[row + 1][col];\n            const neighborNodeLeft = grid[row - 1][col];\n            if (!disjointSet.inSameSet(neighborNodeLeft, neighborNodeRight)) {\n                node.isWall = false;\n                disjointSet.union(neighborNodeLeft, neighborNodeRight);\n            }\n            vWallSet.splice(random2, 1);\n        }\n    }\n    // console.log(grid);\n    return grid;\n}","import DisjointSet from '../Data Structures/disjointSet';\nlet disjointSet = new DisjointSet((node) => {\n    return node.index;\n});\n\nfunction createNode(row, col, finishNode, startNode) {\n    const srow = startNode.row;\n    const scol = startNode.col;\n    const frow = finishNode.row;\n    const fcol = finishNode.col;\n    return {\n        row: row,\n        col: col,\n        isVisited: false,\n        isWall: false,\n        parent: null,\n        isNode: true,\n        isStart:\n            row === srow && col === scol,\n        isFinish:\n            row === frow && col === fcol,\n        weight: 1,\n        costFromSource: (row === srow && col === scol) ? 0 : Number.POSITIVE_INFINITY,\n        index: -1,\n    };\n}\nfunction initialGrid(rowNum, colNum, startNode, finishNode) {\n    disjointSet = new DisjointSet((node) => {\n        return node.index;\n    });\n    const grid = [];\n    let i = 0;\n    for (let r = 0; r < rowNum; r++) {\n        const row = [];\n        for (let c = 0; c < colNum; c++) {\n            const newNode = createNode(r, c, finishNode, startNode);\n            if ((r % 2 === 0 || c % 2 === 0)) {\n                newNode.isWall = true;\n            }\n            else {\n                newNode.index = i;\n                i++;\n                disjointSet.makeSet(newNode);\n            }\n            if (newNode.isFinish || newNode.isStart) newNode.isWall = false;\n            row.push(newNode);\n        }\n        grid.push(row);\n    }\n    return grid;\n}\n\nfunction getChildren(node,grid) {\n    const childDirection = [[2,0],[0,2],[-2,0],[0,-2]];\n    const children = [];\n    const {row,col} = node;\n    childDirection.forEach(direction => {\n        const childRow = row + direction[0];\n        const childCol = col + direction[1];\n        if(childRow > 0 && childCol > 0 && childRow < grid.length && childCol < grid[0].length){\n            const childNode = grid[childRow][childCol];\n            children.push(childNode);            \n        }\n    });\n    return children;\n}\nfunction removeWall(nodeA, nodeB, grid) {\n\n    const rowA = nodeA.row;\n    const colA = nodeA.col;\n    const rowB = nodeB.row;\n    const colB = nodeB.col;\n\n    const r = Math.floor((rowA + rowB) / 2);\n    const c = Math.floor((colA + colB) / 2);\n\n    grid[r][c].isWall = false;\n    return;\n}\nfunction unionJoint(node,currentNode,grid){\n    const children = getChildren(node,grid);\n    children.forEach(child => {\n        if(disjointSet.inSameSet(child,currentNode) && !disjointSet.inSameSet(currentNode,node))\n        {\n            removeWall(child,node,grid);\n            disjointSet.union(currentNode, node);\n        }\n    });\n    return;\n}\nexport function primMaze(rowNum, colNum, startNode, finishNode) {\n    const grid = initialGrid(rowNum, colNum, startNode, finishNode);\n\n    let currentNode = grid[1][1];\n    const edgeQueue= [grid[3][1],grid[1][3]];\n    grid[3][1].isVisited = true;\n    grid[1][3].isVisited = true;\n    while(edgeQueue.length)\n    {\n        const random = Math.floor(Math.random()*edgeQueue.length);\n        // removeWall(currentNode,edgeQueue[random],grid);\n        unionJoint(edgeQueue[random],currentNode,grid);\n        currentNode =  edgeQueue[random];\n        // console.log(currentNode);\n        const children = getChildren(currentNode,grid);\n        if(children.length){\n            children.forEach(child=>{\n                if(!child.isVisited){\n                    edgeQueue.push(child);\n                    child.isVisited = true;\n                }\n            });\n        }\n        edgeQueue.splice(random,1);\n    }\n    grid.forEach(row=>{\n        row.forEach(node=>{\n            node.isVisited = false;\n        });\n    });\n    return grid;\n}","import React from 'react';\nimport Node from './Node/Node';\nimport './PathfindingVisualizer.css'\nimport { bfs } from './Algorithms/bfs'\nimport { dfs } from './Algorithms/dfs'\nimport { dijkstra } from './Algorithms/dijkstra'\nimport { maze } from './Mazes/maze'\nimport { weightMaze } from './Mazes/weightMaze'\nimport { wallMaze } from './Mazes/wallMaze'\nimport Navbar from '../Navbar';\nimport {horizontalSkewMaze} from './Mazes/hSkewMaze';\nimport { verticalSkewMaze } from './Mazes/vSkewMaze';\nimport { kruskalMaze } from './Mazes/kruskalsMaze1';\nimport {primMaze} from './Mazes/primsMaze';\nclass PathfindingVisualizer extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            grid: [],\n            ROW_COUNT: 25,\n            COLUMN_COUNT: 35,\n            START_NODE_ROW: 5,\n            FINISH_NODE_ROW: 20,\n            START_NODE_COL: 5,\n            FINISH_NODE_COL: 30,\n            isRunning: false,\n            mouseIsPressed: false,\n            startNodePressed: false,\n            finishNodePressed: false,\n            navbarHeight: 0,\n            weightWallToggle:false,\n            // isStartNode: false,\n            // isFinishNode: false,\n            // isWallNode: false, // xxxxxxx\n            // currRow: 0,\n            // currCol: 0,\n            // isDesktopView: true,\n        };\n        // this.handleMouseLeave = this.handleMouseLeave.bind(this);\n\n    }\n\n    navbarHeight = (height) => {\n        // console.log(\"Arguement passed = \",height);\n        const navbarHeight = height;\n        // console.log(navbarHeight);\n        this.setState({ navbarHeight });\n        // return navbarHeight;\n    }\n\n    toggleIsRunning = () => {\n        let isRunning = !this.state.isRunning;\n        this.setState({ isRunning });\n    }\n    toggleWeightWallToggle = () =>{\n        const weightWallToggle = !this.state.weightWallToggle;\n        this.setState({weightWallToggle});\n    }\n\n    getInitialGrid = (\n        rowCount = this.state.ROW_COUNT,\n        colCount = this.state.COLUMN_COUNT,\n    ) => {\n        const initialGrid = [];\n        for (let row = 0; row < rowCount; row++) {\n            const currentRow = [];\n            for (let col = 0; col < colCount; col++) {\n                currentRow.push(this.createNode(row, col));\n            }\n            initialGrid.push(currentRow);\n        }\n        return initialGrid;\n    };\n\n    createNode = (row, col) => {\n        return {\n            row,\n            col,\n            isStart:\n                row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL,\n            isFinish:\n                row === this.state.FINISH_NODE_ROW &&\n                col === this.state.FINISH_NODE_COL,\n            isVisited: false,\n            isWall: false,\n            parent: null,\n            isNode: true,\n            weight: 1,\n            costFromSource: (row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL) ? 0 : Number.POSITIVE_INFINITY,\n            // extraClassName:\"\",\n        };\n    };\n\n    clearGrid = () => {\n        if (!this.state.isRunning) {\n            let grid = this.state.grid;\n\n            for (const row of grid) {\n                for (const node of row) {\n                    if (!node.isStart && !node.isFinish && !node.isWall) {\n                        document.getElementById(\n                            `node-${node.row}-${node.col}`\n                        ).className = 'node';\n                        node.isVisited = false;\n                        node.parent = null;\n                        node.costFromSource = Number.POSITIVE_INFINITY;\n                        // nodeClassName = 'node';\n                    }\n                    else if (node.isStart || node.isFinish) {\n                        node.parent = null;\n                        node.isVisited = false;\n                        if(node.isStart) node.costFromSource = 0;\n                        else node.costFromSource = Number.POSITIVE_INFINITY;\n                    }\n                }\n            }\n            this.setState({ grid });\n            // console.log(grid);\n        }\n    }\n    clearWallsandWeights = () => {\n        if (!this.state.isRunning) {\n            let grid = this.state.grid;\n\n            for (const row of grid) {\n                for (const node of row) {\n                    if (node.isWall ) {\n                        document.getElementById(\n                            `node-${node.row}-${node.col}`\n                        ).className = 'node';\n                        node.isVisited = false;\n                        node.parent = null;\n                        node.isWall = false;\n                        node.costFromSource = Number.POSITIVE_INFINITY;\n                        // nodeClassName = 'node';\n                    }\n                    if (node.weight !==1)\n                    {\n                        node.weight = 1;\n                        node.costFromSource = node.isStart ? 0: Number.POSITIVE_INFINITY;\n                    }\n                }\n            }\n            this.setState({ grid });\n\n            // console.log(grid);\n        }\n    }\n    resetGrid = () => {\n        if (!this.state.isRunning) {\n            let grid = this.state.grid;\n\n            for (const row of grid) {\n                for (const node of row) {\n                    if (!node.isStart && !node.isFinish) {\n                        document.getElementById(\n                            `node-${node.row}-${node.col}`\n                        ).className = 'node';\n                        node.isVisited = false;\n                        node.parent = null;\n                        node.isWall = false;\n                        // nodeClassName = 'node';\n                    }\n                    else if (node.isStart || node.isFinish) {\n                        node.parent = null;\n                        node.isVisited = false;\n                    }\n                }\n            }\n            this.setState({ grid });\n            // console.log(grid);\n        }\n    }\n\n    onCellDown = (row, col) => {\n        if (!this.state.isRunning && !this.state.weightWallToggle) {\n\n            const grid = this.state.grid;\n            if (!this.state.mouseIsPressed) {\n                const mouseIsPressed = !this.state.mouseIsPressed;\n                this.setState({ mouseIsPressed });\n                const currentNode = grid[row][col];\n                if (!currentNode.isStart && !currentNode.isFinish) {\n                    if (currentNode.isWall) {\n                        document.getElementById(`node-${row}-${col}`).className = 'node';\n                        currentNode.isWall = false;\n                    }\n                    else {\n                        document.getElementById(`node-${row}-${col}`).className = 'node node-wall';\n                        currentNode.isWall = true;\n                        currentNode.weight=1;\n                    }\n                }\n                else if (currentNode.isStart) {\n                    const startNodePressed = !this.state.startNodePressed;\n                    this.setState({ startNodePressed });\n                    document.getElementById(`node-${row}-${col}`).className = 'node';\n                    currentNode.isStart = false;\n                }\n                else if (currentNode.isFinish) {\n                    const finishNodePressed = !this.state.finishNodePressed;\n                    this.setState({ finishNodePressed });\n                    document.getElementById(`node-${row}-${col}`).className = 'node' ;\n                    currentNode.isFinish = false;\n                }\n            }\n        }\n        else if(!this.state.isRunning && this.state.weightWallToggle)\n        {\n            const grid = this.state.grid;\n            const currentNode = grid[row][col];\n            if(!currentNode.isWall){\n                currentNode.weight = currentNode.weight+1;\n            }\n        }\n    }\n    onCellEnter = (row, col) => {\n        if (!this.state.isRunning && this.state.mouseIsPressed) {\n            const grid = this.state.grid;\n            const currentNode = grid[row][col];\n            if (!currentNode.isStart && !currentNode.isFinish && !this.state.startNodePressed && !this.state.finishNodePressed) {\n                document.getElementById(`node-${row}-${col}`).className = 'node node-wall';\n                currentNode.isWall = true;\n                currentNode.weight = 1;\n            }\n            else if (this.state.startNodePressed) {\n                const START_NODE_ROW = row;\n                const START_NODE_COL = col;\n                this.setState({ START_NODE_ROW, START_NODE_COL });\n                document.getElementById(`node-${row}-${col}`).className = 'node node-start';\n            }\n            else if (this.state.finishNodePressed) {\n                const FINISH_NODE_ROW = row;\n                const FINISH_NODE_COL = col;\n                this.setState({ FINISH_NODE_ROW, FINISH_NODE_COL });\n                document.getElementById(`node-${row}-${col}`).className = 'node node-finish';\n            }\n\n        }\n    }\n    onCellLeave = (row, col) => {\n        const grid = this.state.grid;\n        if (this.state.startNodePressed) {\n            if (!grid[row][col].isFinish && !grid[row][col].isWall) document.getElementById(`node-${row}-${col}`).className = 'node';\n            else if (grid[row][col].isFinish) document.getElementById(`node-${row}-${col}`).className = 'node node-finish';\n            else if (grid[row][col].isWall) document.getElementById(`node-${row}-${col}`).className = 'node node-wall';\n        }\n        else if (this.state.finishNodePressed) {\n            if (!grid[row][col].isStart && !grid[row][col].isWall) document.getElementById(`node-${row}-${col}`).className = 'node';\n            else if (grid[row][col].isStart) document.getElementById(`node-${row}-${col}`).className = 'node node-start';\n            else if (grid[row][col].isWall) document.getElementById(`node-${row}-${col}`).className = 'node node-wall';\n        }\n    }\n    onCellRelease = () => {\n        const mouseIsPressed = false;\n        const grid = this.state.grid;\n        if (this.state.startNodePressed) {\n            const row = this.state.START_NODE_ROW;\n            const col = this.state.START_NODE_COL;\n            document.getElementById(`node-${row}-${col}`).className = 'node node-start';\n            grid[row][col].isStart = true;\n            grid[row][col].isWall = false;\n        }\n        else if (this.state.finishNodePressed) {\n            const row = this.state.FINISH_NODE_ROW;\n            const col = this.state.FINISH_NODE_COL;\n            document.getElementById(`node-${row}-${col}`).className = 'node node-finish';\n            grid[row][col].isFinish = true;\n            grid[row][col].isWall = false;\n        }\n        const startNodePressed = false;\n        const finishNodePressed = false;\n        this.setState({ mouseIsPressed, startNodePressed, finishNodePressed, grid });\n    }\n\n\n\n    componentWillMount = () => {\n        const ROW_COUNT = 2 * Math.floor(Math.floor((document.documentElement.clientHeight - this.state.navbarHeight) / 25) / 2) - 3;\n        const COLUMN_COUNT = 2 * Math.floor(Math.floor(document.documentElement.clientWidth / 25) / 2) - 3;\n        const START_NODE_ROW = Math.floor(ROW_COUNT / 2);\n        const FINISH_NODE_ROW = Math.floor(ROW_COUNT / 2);\n        const START_NODE_COL = Math.floor(COLUMN_COUNT / 4);\n        const FINISH_NODE_COL = Math.floor(3 * COLUMN_COUNT / 4);\n        this.setState({ ROW_COUNT, COLUMN_COUNT, START_NODE_ROW, START_NODE_COL, FINISH_NODE_ROW, FINISH_NODE_COL });\n    }\n    componentDidMount = () => {\n        const grid = this.getInitialGrid();\n        this.setState({ grid });\n        // console.log(grid);\n    }\n\n\n\n    visualize(algo) {\n        if (!this.state.isRunning) {\n            this.clearGrid();\n            this.toggleIsRunning();\n            const { grid } = this.state;\n            const startNode =\n                grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\n            const finishNode =\n                grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\n            let visitedNodesInOrder;\n            switch (algo) {\n                case 'Dijkstra':\n                    visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n                    break;\n                // case 'AStar':\n                //     visitedNodesInOrder = AStar(grid, startNode, finishNode);\n                //     break;\n                case 'BFS':\n                    visitedNodesInOrder = bfs(grid, startNode, finishNode);\n                    break;\n                case 'DFS':\n                    visitedNodesInOrder = dfs(grid, startNode, finishNode);\n                    break;\n                default:\n                    // should never get here\n                    break;\n            }\n\n            // console.log(visitedNodesInOrder);\n            // console.log(grid);\n            const nodesInShortestPathOrder = this.getNodesInShortestPathOrder(finishNode);\n            nodesInShortestPathOrder.push('end');\n            this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\n        }\n    }\n\n    animate(visitedNodesInOrder, nodesInShortestPathOrder) {\n        for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n            if (i === visitedNodesInOrder.length) {\n                setTimeout(() => {\n                    this.animateShortestPath(nodesInShortestPathOrder);\n                }, 2 * i);\n                return;\n            }\n            setTimeout(() => {\n                const node = visitedNodesInOrder[i];\n                const nodeClassName = document.getElementById(\n                    `node-${node.row}-${node.col}`,\n                ).className;\n                if (\n                    nodeClassName !== 'node node-start' &&\n                    nodeClassName !== 'node node-finish'\n                ) {\n                    document.getElementById(`node-${node.row}-${node.col}`).className = \n                        'node node-visited' ;\n                }\n            }, 2 * i);\n        }\n    }\n\n    /******************** Create path from start to finish ********************/\n    animateShortestPath(nodesInShortestPathOrder) {\n        for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n            if (nodesInShortestPathOrder[i] === 'end') {\n                setTimeout(() => {\n                    this.toggleIsRunning();\n                    // console.log(\"Completed\");\n                }, i * 50);\n            } else {\n                setTimeout(() => {\n                    const node = nodesInShortestPathOrder[i];\n                    const nodeClassName = document.getElementById(\n                        `node-${node.row}-${node.col}`,\n                    ).className;\n                    if (\n                        nodeClassName !== 'node node-start'&&\n                        nodeClassName !== 'node node-finish'\n                    ) {\n                        document.getElementById(`node-${node.row}-${node.col}`).className = \n                            'node node-shortest-path';\n                    }\n                }, i * 40);\n            }\n        }\n    }\n\n    getNodesInShortestPathOrder(finishNode) {\n        const nodesInShortestPathOrder = [];\n        let currentNode = finishNode;\n        while (currentNode !== null) {\n            nodesInShortestPathOrder.unshift(currentNode);\n            currentNode = currentNode.parent;\n        }\n        return nodesInShortestPathOrder;\n    }\n\n    mazify = () => {\n        if (!this.state.isRunning) {\n            const startNode = this.state.grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\n            const finishNode = this.state.grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\n            const grid = maze(this.state.ROW_COUNT, this.state.COLUMN_COUNT, startNode, finishNode);\n            this.setState({ grid });\n        }\n    }\n    hSkewMazify = ()=>{\n        if(!this.state.isRunning){\n            const startNode = this.state.grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\n            const finishNode = this.state.grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\n            const grid = horizontalSkewMaze(this.state.ROW_COUNT, this.state.COLUMN_COUNT, startNode, finishNode);\n            this.setState({ grid });\n        }\n    }\n    vSkewMazify = () => {\n        if (!this.state.isRunning) {\n            const startNode = this.state.grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\n            const finishNode = this.state.grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\n            const grid = verticalSkewMaze(this.state.ROW_COUNT, this.state.COLUMN_COUNT, startNode, finishNode);\n            this.setState({ grid });\n        }\n    }\n    kruskalMazify = () =>{\n        if (!this.state.isRunning) {\n            const startNode = this.state.grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\n            const finishNode = this.state.grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\n            const grid = kruskalMaze(this.state.ROW_COUNT, this.state.COLUMN_COUNT, startNode, finishNode);\n            this.setState({ grid });\n        }\n    }\n    primMazify = () => {\n        if (!this.state.isRunning) {\n            const startNode = this.state.grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\n            const finishNode = this.state.grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\n            const grid = primMaze(this.state.ROW_COUNT, this.state.COLUMN_COUNT, startNode, finishNode);\n            this.setState({ grid });\n        }\n    }\n    weightMazify = ()=>{\n        let grid = this.state.grid;\n        grid = weightMaze(grid);\n        this.setState({grid});\n    }\n    wallMazify = ()=>{\n        let grid = this.state.grid;\n        grid = wallMaze(grid);\n        this.setState({ grid });\n    }\n\n    render() {\n        return (\n            <div>\n                <Navbar\n                    dfs={() => this.visualize('DFS')}\n                    bfs={() => this.visualize('BFS')}\n                    dijkstra={() => this.visualize('Dijkstra')}\n                    clearGrid={() => this.clearGrid()}\n                    resetGrid={() => this.resetGrid()}\n                    clearWallsandWeights={() => this.clearWallsandWeights()}\n                    mazify={() => this.mazify()}\n                    hmazify={() => this.hSkewMazify()}\n                    vmazify={() => this.vSkewMazify()}\n                    kruskalMazify={() => this.kruskalMazify()}\n                    primMazify={() => this.primMazify()}\n                    weightMazify={()=>this.weightMazify()}\n                    wallMazify={() => this.wallMazify()}\n                    navbarHeight={this.navbarHeight}\n                    weightWallToggle={()=>this.toggleWeightWallToggle()}\n                ></Navbar>\n                <table className=\"center grid-container\" >\n                    <tbody className=\"grid\">\n                        {\n                            this.state.grid.map((row, rowID) => {\n                                return (\n                                    <tr key={rowID} >\n                                        {\n                                            row.map((node, nodeID) => {\n                                                const { row, col, isFinish, isStart, isWall, weight } = node;\n\n                                                return (\n                                                    <Node\n                                                        key={nodeID}\n                                                        row={row}\n                                                        col={col}\n                                                        weight={weight}\n                                                        isFinish={isFinish}\n                                                        isStart={isStart}\n                                                        isWall={isWall}\n                                                        onMouseDown={(x, y) => { this.onCellDown(x, y) }}\n                                                        onMouseEnter={(x, y) => this.onCellEnter(x, y)}\n                                                        onMouseUp={() => this.onCellRelease()}\n                                                        onMouseLeave={(x, y) => this.onCellLeave(x, y)}\n                                                    ></Node>\n                                                );\n                                            })\n                                        }\n\n                                    </tr>\n                                );\n                            })\n                        }\n                    </tbody>\n                </table>\n                {/* <button onClick={() => this.visualize('BFS')}>BFS</button>\n                <button onClick={() => this.visualize('DFS')}>DFS</button>\n                <button onClick={() => this.clearGrid()}>Clear Gridd</button>\n                <button onClick={() => this.resetGrid()}>Reset Grid</button>\n                <button onClick={() => this.mazify()}>Maze</button> */}\n\n            </div>\n        )\n    }\n\n}\n\nexport default PathfindingVisualizer;\n","export function wallMaze(grid) {\n    grid.forEach(row => {\n        row.forEach(node => {\n            if (!node.isWall && !node.isStart && !node.isFinish) {\n                const random = Math.floor(Math.random()*4);\n                if(random===0)\n                {\n                    node.isWall = true;\n                    node.weight = 1;\n                }\n            }\n        });\n    });\n    return grid;\n}","// // BFS\n\nexport function bfs (grid,startNode,finishNode) {\n\n    // console.log(grid);\n    // console.log(startNode, finishNode);\n\n    const visitedNodesInOrder = [];\n    let bfsQueue = [startNode];\n    startNode.isVisited = true;\n    const childDirections = [[1,0],[0,1],[-1,0],[0,-1]] ;\n\n    while(bfsQueue.length)\n    {\n        const currentNode = bfsQueue.shift();\n        if (currentNode === finishNode) return visitedNodesInOrder;\n        visitedNodesInOrder.push(currentNode);\n        const {row,col} = currentNode;\n\n        childDirections.forEach(direction => {\n            let x = row + direction[0];\n            let y = col + direction[1];\n\n            if(x>=0 && y>=0 && x<grid.length && y<grid[0].length && !grid[x][y].isWall && !grid[x][y].isVisited)\n            {\n                bfsQueue.push(grid[x][y]);\n                grid[x][y].isVisited = true;\n                grid[x][y].parent = currentNode;\n            }\n        });\n    }\n    return visitedNodesInOrder;\n}\n\n","import './App.css';\n// import Navbar from './Navbar';\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer'\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer/>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}